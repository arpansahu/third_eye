pipeline {
    agent { label 'local' }
    parameters {
        booleanParam(name: 'DEPLOY', defaultValue: true, description: 'Enable deployment')
        choice(name: 'DEPLOY_TYPE', choices: ['kubernetes', 'docker'], description: 'Select deployment type')
        string(name: 'IMAGE_TAG', defaultValue: '', description: 'Image tag to deploy (leave empty to auto-detect from build)')
    }
    environment {
        REGISTRY = "harbor.arpansahu.space"
        REPOSITORY = "library/third_eye"
        KUBECONFIG = "${env.WORKSPACE}/kubeconfig"
        NGINX_CONF = "/etc/nginx/sites-available/third-eye"
        ENV_PROJECT_NAME = "third_eye"
        DOCKER_PORT = "8008"
        PROJECT_NAME_WITH_DASH = "third-eye"
        SERVER_NAME = "third-eye.arpansahu.space"
        BUILD_PROJECT_NAME = "third_eye_build"
        JENKINS_DOMAIN = "jenkins.arpansahu.space"
        SENTRY_ORG = "arpansahu"
        SENTRY_PROJECT = "third_eye"
    }
    stages {
        stage('Initialize') {
            steps {
                script {
                    echo "Current workspace path is: ${env.WORKSPACE}"
                }
            }
        }
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        stage('Setup Environment') {
            steps {
                script {
                    echo "Loading environment variables from Jenkins credentials..."
                    withCredentials([file(credentialsId: 'third_eye_env_file', variable: 'ENV_FILE')]) {
                        // Remove existing .env file if it exists (handles read-only files)
                        sh 'rm -f .env || true'
                        
                        sh "cp \$ENV_FILE .env"
                        echo "✅ Environment file created successfully"
                    }
                }
            }
        }
                    }
                }
            }
        }
        stage('Setup Kubernetes Config') {
            when {
                expression { return params.DEPLOY_TYPE == 'kubernetes' }
            }
            steps {
                script {
                    // Copy the kubeconfig file to the workspace
                    sh "sudo cp /root/.kube/config ${env.WORKSPACE}/kubeconfig"
                    // Change permissions of the kubeconfig file
                    sh "sudo chmod 644 ${env.WORKSPACE}/kubeconfig"
                }
            }
        }
        stage('Check & Create Nginx Configuration') {
            steps {
                script {
                    // Check if the Nginx configuration file exists
                    def configExists = sh(script: "test -f ${NGINX_CONF} && echo 'exists' || echo 'not exists'", returnStdout: true).trim()

                    if (configExists == 'not exists') {
                        echo "Nginx configuration file does not exist. Creating it now..."

                        // Create or overwrite the NGINX_CONF file with the content of nginx.conf using sudo tee
                        sh "sudo cat nginx.conf | sudo tee ${NGINX_CONF} > /dev/null"

                        // Replace placeholders in the configuration file
                        sh "sudo sed -i 's|SERVER_NAME|${SERVER_NAME}|g' ${NGINX_CONF}"
                        sh "sudo sed -i 's|DOCKER_PORT|${DOCKER_PORT}|g' ${NGINX_CONF}"

                        echo "Nginx configuration file created."

                        // Ensure Nginx is aware of the new configuration
                        sh "sudo ln -sf ${NGINX_CONF} /etc/nginx/sites-enabled/"
                    } else {
                        echo "Nginx configuration file already exists."
                    }                    
                }
            }
        }
        stage('Retrieve Image Tag from Build Job') {
            steps {
                script {
                    // Check if IMAGE_TAG parameter was provided
                    if (params.IMAGE_TAG) {
                        echo "Using provided image tag: ${params.IMAGE_TAG}"
                        env.IMAGE_TAG = params.IMAGE_TAG
                    } else {
                        echo "No image tag provided. Retrieving from ${BUILD_PROJECT_NAME}"

                        // Construct the API URL for the latest successful build
                        def api_url = "https://${JENKINS_DOMAIN}/job/${BUILD_PROJECT_NAME}/lastSuccessfulBuild/api/json"

                        echo "Hitting API URL: ${api_url}"
                        
                        withCredentials([usernamePassword(credentialsId: 'jenkins-admin-credentials', usernameVariable: 'JENKINS_USER', passwordVariable: 'JENKINS_TOKEN')]) {
                            // Execute the curl command to retrieve the JSON response
                            def buildInfoJson = sh(script: "curl -u ${JENKINS_USER}:${JENKINS_TOKEN} ${api_url}", returnStdout: true).trim()

                            // Log the raw JSON response for debugging
                            echo "Raw JSON response: ${buildInfoJson}"

                            // Extract the build number using grep
                            def imageTag = sh(script: """
                                echo '${buildInfoJson}' | grep -o '"id":"[0-9]*"' | head -1 | tr -dc '0-9'
                            """, returnStdout: true).trim()

                            echo "Retrieved image tag (build number): ${imageTag}"

                            // Update IMAGE_TAG environment variable
                            env.IMAGE_TAG = imageTag
                        }
                    }

                    echo "Using image tag: ${env.IMAGE_TAG}"

                    if (REGISTRY && REPOSITORY && env.IMAGE_TAG) {
                        if (params.DEPLOY_TYPE == 'kubernetes') {
                            // Replace the placeholder in the deployment YAML
                            sh "sed -i 's|:latest|:${env.IMAGE_TAG}|g' ${WORKSPACE}/deployment.yaml"
                        }
                        
                        if (params.DEPLOY_TYPE == 'docker') {
                            // Update docker-compose.yml with correct image tag
                            sh """
                            sed -i 's|image: .*|image: ${REGISTRY}/${REPOSITORY}:${env.IMAGE_TAG}|' docker-compose.yml
                            """
                        }
                    } else {
                        echo "One or more required variables (REGISTRY, REPOSITORY, IMAGE_TAG) are not defined. Skipping image update."
                    }
                }
            }
        }
        stage('Deploy') {
            when {
                expression { params.DEPLOY }
            }
            steps {
                script {
                    if (params.DEPLOY_TYPE == 'docker') {
                        // Deploy using Docker Compose
                        sh 'docker compose down'
                        sh 'docker rm -f ${ENV_PROJECT_NAME} || true'  // Remove any orphaned container
                        sh 'docker compose pull'
                        sh 'docker compose up -d'

                        // Verify the container is running
                        def containerRunning = sh(script: "docker ps -q -f name=${ENV_PROJECT_NAME}", returnStdout: true).trim()
                        if (!containerRunning) {
                            error "Container ${ENV_PROJECT_NAME} is not running"
                        } else {
                            echo "Container ${ENV_PROJECT_NAME} is running"
                            // Health check with retry mechanism (migrations + collectstatic take time)
                            sh """
                                set +e  # Don't exit on error
                                MAX_RETRIES=20
                                RETRY_DELAY=30
                                ATTEMPT=0
                                HTTP_STATUS=000
                                
                                echo "⏳ Waiting for Django app to start (migrations + collectstatic running)..."
                                
                                while [ \$ATTEMPT -lt \$MAX_RETRIES ]; do
                                    ATTEMPT=\$((ATTEMPT + 1))
                                    echo "Health check attempt \$ATTEMPT/\$MAX_RETRIES..."
                                    HTTP_STATUS=\$(curl -s -o /dev/null -w "%{http_code}" -L http://localhost:${DOCKER_PORT} || echo "000")
                                    echo "HTTP Status: \$HTTP_STATUS"
                                    
                                    if [ "\$HTTP_STATUS" = "200" ] || [ "\$HTTP_STATUS" = "302" ]; then
                                        echo "✅ Service is responding! HTTP Status: \$HTTP_STATUS"
                                        break
                                    fi
                                    
                                    if [ \$ATTEMPT -lt \$MAX_RETRIES ]; then
                                        echo "⏳ Service not ready yet. Waiting \${RETRY_DELAY}s before retry..."
                                        sleep \$RETRY_DELAY
                                    fi
                                done
                                
                                set -e  # Re-enable exit on error
                                
                                # Final check
                                if [ "\$HTTP_STATUS" != "200" ] && [ "\$HTTP_STATUS" != "302" ]; then
                                    echo "❌ Service failed to start after \$MAX_RETRIES attempts"
                                    docker logs ${ENV_PROJECT_NAME} || true
                                    exit 1
                                fi
                                
                                # Update Nginx configuration
                                sudo sed -i 's|proxy_pass .*;|proxy_pass http://0.0.0.0:${DOCKER_PORT};|' ${NGINX_CONF}
                                sudo nginx -s reload
                                echo '✅ Nginx configuration updated and reloaded successfully.'
                                
                                # Scale down Kubernetes deployment if running
                                replicas=\$(kubectl get deployment ${PROJECT_NAME_WITH_DASH}-app -o=jsonpath='{.spec.replicas}' 2>/dev/null || echo "0")
                                if [ "\$replicas" != "" ] && [ "\$replicas" -gt 0 ]; then
                                    kubectl scale deployment ${PROJECT_NAME_WITH_DASH}-app --replicas=0
                                    echo '✅ Kubernetes deployment scaled down successfully.'
                                fi
                            """
                        }
                    } else if (params.DEPLOY_TYPE == 'kubernetes') {
                        // Kubernetes deployment
                        echo "Deploying to Kubernetes..."

                        // Verify Kubernetes configuration
                        sh 'kubectl cluster-info'
                        
                        // Delete existing secret if it exists
                        sh "kubectl delete secret ${PROJECT_NAME_WITH_DASH}-secret || true"

                        // Deploy to Kubernetes
                        sh """
                        kubectl create secret generic ${PROJECT_NAME_WITH_DASH}-secret --from-env-file=${WORKSPACE}/.env
                        kubectl apply -f ${WORKSPACE}/service.yaml
                        kubectl apply -f ${WORKSPACE}/deployment.yaml
                        """
                        
                        echo "Waiting for deployment to be ready..."
                        sleep 60

                        // Check deployment status
                        sh "kubectl describe deployment/${PROJECT_NAME_WITH_DASH}-app"
                        
                        // Verify service and get NodePort
                        def nodePort = sh(script: "kubectl get service ${PROJECT_NAME_WITH_DASH}-service -o=jsonpath='{.spec.ports[0].nodePort}'", returnStdout: true).trim()
                        echo "Service NodePort: ${nodePort}"

                        // Get cluster IP address
                        def clusterIP = sh(script: "kubectl get nodes -o=jsonpath='{.items[0].status.addresses[0].address}'", returnStdout: true).trim()
                        echo "Cluster IP: ${clusterIP}"

                        // Verify service accessibility and update Nginx
                        sh """
                            HTTP_STATUS=\$(curl -s -o /dev/null -w "%{http_code}" -L http://${clusterIP}:${nodePort})
                            echo "HTTP Status: \$HTTP_STATUS"
                            
                            if [ "\$HTTP_STATUS" -eq 200 ] || [ "\$HTTP_STATUS" -eq 302 ]; then
                                echo "Service is reachable at http://${clusterIP}:${nodePort}"

                                echo "Updating Nginx configuration at ${NGINX_CONF}..."
                                sudo sed -i 's|proxy_pass .*;|proxy_pass http://${clusterIP}:${nodePort};|' ${NGINX_CONF}
                                
                                echo "Reloading Nginx..."
                                sudo nginx -s reload
                                
                                echo "Nginx reloaded successfully"
                                
                                # Stop Docker Compose if running
                                docker compose down || true
                                
                                echo "Kubernetes deployment successful."
                            else
                                echo "Service health check failed. HTTP Status: \$HTTP_STATUS"
                                kubectl logs -l app=${PROJECT_NAME_WITH_DASH} --tail=100 || true
                                exit 1
                            fi
                        """
                    } else {
                        error "Invalid DEPLOY_TYPE: ${params.DEPLOY_TYPE}"
                    }
                }
            }
        }
                            
                            # Remove Docker container if running
                            DOCKER_CONTAINER=\$(docker ps -q -f name=${env.ENV_PROJECT_NAME})
                            if [ "\$DOCKER_CONTAINER" ]; then
                                echo "Docker container ${env.ENV_PROJECT_NAME} is running. Removing it..."
                                docker rm -f ${env.ENV_PROJECT_NAME}
                            else
                                echo "Docker container ${env.ENV_PROJECT_NAME} is not running. Skipping removal"
                            fi
                        else
                            echo "Service is not reachable at http://${clusterIP}:${nodePort}. HTTP Status: \$HTTP_STATUS"
                            exit 1
                        fi
                    """
                    env.BUILD_STATUS = 'DEPLOYED'
                }
            }
        }
        stage('Sentry Release') {
            when {
                expression { params.DEPLOY && env.BUILD_STATUS == 'DEPLOYED' }
            }
            steps {
                script {
                    withCredentials([string(credentialsId: 'sentry-auth-token', variable: 'SENTRY_AUTH_TOKEN')]) {
                        sh """
                        VERSION=\$(git rev-parse HEAD)
                        sentry-cli releases -o ${env.SENTRY_ORG} -p ${env.SENTRY_PROJECT} new \$VERSION || true
                        sentry-cli releases -o ${env.SENTRY_ORG} -p ${env.SENTRY_PROJECT} set-commits --auto \$VERSION || true
                        sentry-cli releases -o ${env.SENTRY_ORG} -p ${env.SENTRY_PROJECT} deploys \$VERSION new -e ${env.SENTRY_ENVIRONMENT} || true
                        sentry-cli releases -o ${env.SENTRY_ORG} -p ${env.SENTRY_PROJECT} finalize \$VERSION || true
                        """
                    }
                }
            }
        }
    }
    post {
        success {
            script {
                if (env.BUILD_STATUS == 'DEPLOYED') {
                    withCredentials([
                        string(credentialsId: 'mailjet-api-key', variable: 'MAIL_JET_API_KEY'),
                        string(credentialsId: 'mailjet-api-secret', variable: 'MAIL_JET_API_SECRET')
                    ]) {
                        sh """curl -s \
                        -X POST \
                        --user \$MAIL_JET_API_KEY:\$MAIL_JET_API_SECRET \
                        https://api.mailjet.com/v3.1/send \
                        -H "Content-Type:application/json" \
                        -d '{
                            "Messages":[
                                    {
                                            "From": {
                                                    "Email": "${env.MAIL_JET_EMAIL_ADDRESS}",
                                                    "Name": "Jenkins Notification"
                                            },
                                            "To": [
                                                    {
                                                            "Email": "${env.MY_EMAIL_ADDRESS}",
                                                            "Name": "Development Team"
                                                    }
                                            ],
                                            "Subject": "Jenkins Build Pipeline your project ${currentBuild.fullDisplayName} Ran Successfully",
                                            "TextPart": "Hola Development Team, your project ${currentBuild.fullDisplayName} is now deployed",
                                            "HTMLPart": "<h3>Hola Development Team, your project ${currentBuild.fullDisplayName} is now deployed </h3> <br> <p> Build Url: ${env.BUILD_URL}  </p>"
                                    }
                            ]
                        }' || true"""
                    }

                    // Trigger common_readme job
                    def commitMessage = sh(script: "git log -1 --pretty=%B", returnStdout: true).trim()
                    if (!commitMessage.contains("Automatic Update")) {
                        def expandedProjectUrl = "https://github.com/arpansahu/${env.ENV_PROJECT_NAME}"
                        build job: 'common_readme', parameters: [
                            string(name: 'project_git_url', value: expandedProjectUrl),
                            string(name: 'environment', value: 'prod')
                        ], wait: false
                    }
                }
            }
        }
        failure {
            script {
                withCredentials([
                    string(credentialsId: 'mailjet-api-key', variable: 'MAIL_JET_API_KEY'),
                    string(credentialsId: 'mailjet-api-secret', variable: 'MAIL_JET_API_SECRET')
                ]) {
                    sh """curl -s \
                    -X POST \
                    --user \$MAIL_JET_API_KEY:\$MAIL_JET_API_SECRET \
                    https://api.mailjet.com/v3.1/send \
                    -H "Content-Type:application/json" \
                    -d '{
                        "Messages":[
                                {
                                        "From": {
                                                "Email": "${env.MAIL_JET_EMAIL_ADDRESS}",
                                                "Name": "Jenkins Notification"
                                        },
                                        "To": [
                                                {
                                                        "Email": "${env.MY_EMAIL_ADDRESS}",
                                                        "Name": "Developer Team"
                                                }
                                        ],
                                    "Subject": "Jenkins Build Pipeline your project ${currentBuild.fullDisplayName} Failed",
                                    "TextPart": "Hola Development Team, your project ${currentBuild.fullDisplayName} deployment failed",
                                    "HTMLPart": "<h3>Hola Development Team, your project ${currentBuild.fullDisplayName} is not deployed, Build Failed </h3> <br> <p> Build Url: ${env.BUILD_URL}  </p>"
                                }
                        ]
                    }' || true"""
                }
            }
        }
        always {
            // Cleanup
            sh 'rm -f .env || true'
        }
    }
}
