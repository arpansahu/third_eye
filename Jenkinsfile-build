pipeline {
    agent any
    parameters {
        booleanParam(name: 'skip_checks', defaultValue: false, description: 'Skip the Check for Changes stage')
        booleanParam(name: 'SKIP_TESTS', defaultValue: false, description: 'Skip test stages for faster builds')
    }
    environment {
        IMAGE_TAG = "${env.BUILD_ID}"
        COMMIT_FILE = "${env.WORKSPACE}/last_commit.txt"
        BUILD_STATUS = 'NOT_BUILT'  // Initialize to prevent undefined errors
    }
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        stage('Setup Environment') {
            steps {
                script {
                    // Load .env from Jenkins credentials
                    withCredentials([file(credentialsId: 'third_eye_env_file', variable: 'ENV_FILE')]) {
                        // Remove existing .env file if it exists (handles read-only files)
                        sh 'rm -f .env || true'
                        
                        def envContent = readFile(file: env.ENV_FILE)
                        writeFile(file: '.env', text: envContent)
                        
                        // Parse and set environment variables
                        envContent.split('\n').each { line ->
                            if (line && !line.startsWith('#') && line.contains('=')) {
                                def parts = line.split('=', 2)
                                if (parts.length == 2) {
                                    def key = parts[0].trim()
                                    def value = parts[1].trim()
                                    env."${key}" = value
                                }
                            }
                        }
                        
                        // Set build-specific variables
                        env.BUILD_PROJECT_NAME = "${env.ENV_PROJECT_NAME}_build"
                        env.PROJECT_NAME_WITH_DASH = env.ENV_PROJECT_NAME.replace('_', '-')
                        env.REGISTRY = env.DOCKER_REGISTRY
                        env.REPOSITORY = "${env.DOCKER_REPOSITORY}/${env.DOCKER_IMAGE_NAME}"
                    }
                }
            }
        }
        stage('Check for Changes') {
            steps {
                script {
                    if (params.skip_checks) {
                        echo "Skipping Checks is True. Proceeding with build."
                        BUILD_STATUS = 'BUILT'
                        currentBuild.description = "${currentBuild.fullDisplayName} Skipping Checks is True. Proceeding with build."
                    } else {
                        // Get the current commit hash
                        def currentCommit = sh(script: "git rev-parse HEAD", returnStdout: true).trim()
                        echo "Current commit: ${currentCommit}"

                        // Check if the last commit file exists
                        if (fileExists(COMMIT_FILE)) {
                            def lastCommit = readFile(COMMIT_FILE).trim()
                            echo "Last commit: ${lastCommit}"

                            // Compare the current commit with the last commit
                            if (currentCommit == lastCommit) {
                                echo "No changes detected. Skipping build."
                                currentBuild.description = "${currentBuild.fullDisplayName} build skipped due to no changes detected"
                                return
                            } else {
                                // Check for changes in relevant files
                                def changes = sh(script: "git diff --name-only ${lastCommit} ${currentCommit}", returnStdout: true).trim().split("\n")
                                def relevantChanges = changes.findAll { 
                                    !(it in ['README.md', 'SECURITY.md', 'CHANGELOG.md', '.github/dependabot.yml'])
                                }
                                
                                if (relevantChanges.isEmpty()) {
                                    echo "No relevant changes detected. Skipping build."
                                    currentBuild.description = "${currentBuild.fullDisplayName} build skipped due to no relevant changes"
                                    return
                                } else {
                                    echo "Relevant changes detected. Proceeding with build."
                                    BUILD_STATUS = 'BUILT'
                                }
                            }
                        } else {
                            echo "No last commit file found. Proceeding with initial build."
                            BUILD_STATUS = 'BUILT'
                        }

                        // Save the current commit hash to the file
                        writeFile(file: COMMIT_FILE, text: currentCommit)
                    }
                }
            }
        }
        stage('Run Tests') {
            when {
                expression { 
                    return BUILD_STATUS != 'NOT_BUILT' && !params.SKIP_TESTS 
                }
            }
            steps {
                script {
                    echo "Running unit tests..."
                    sh """
                    docker run --rm -v \$(pwd):/app -w /app --env-file .env python:3.10.7 \\
                        bash -c 'pip install -q -r requirements.txt && \\
                                 python -m pytest -m "not ui and not todo" --ignore=tests -v --tb=short'
                    """
                }
            }
        }
        stage('Run UI Tests') {
            when {
                expression { 
                    return BUILD_STATUS != 'NOT_BUILT' && !params.SKIP_TESTS 
                }
            }
            steps {
                script {
                    echo "Running UI tests with Playwright..."
                    sh """
                    docker run --rm -v \$(pwd):/app -w /app --env-file .env \\
                        mcr.microsoft.com/playwright/python:v1.40.0-jammy bash -c '
                            pip install -q -r requirements.txt
                            playwright install chromium
                            python manage.py migrate --settings=third_eye.test_settings --verbosity=0
                            python manage.py runserver 0.0.0.0:8000 --settings=third_eye.test_settings &
                            SERVER_PID=\$!
                            
                            # Wait for server
                            for i in {1..30}; do
                                if curl -s http://127.0.0.1:8000/ > /dev/null 2>&1; then
                                    echo "Server is ready"
                                    break
                                fi
                                echo "Waiting for server... \$i"
                                sleep 1
                            done
                            
                            pytest */test_ui.py -m "ui and not todo" -v --tb=short -x || true
                            TEST_RESULT=\$?
                            kill \$SERVER_PID 2>/dev/null || true
                            exit \$TEST_RESULT
                        '
                    """
                }
            }
        }
        stage('Build Image') {
            when {
                expression { return BUILD_STATUS != 'NOT_BUILT' }
            }
            steps {
                script {
                    // Ensure Docker is running and can be accessed
                    sh 'docker --version'

                    // Log the image details
                    echo "Building Docker image: ${REGISTRY}/${REPOSITORY}:${IMAGE_TAG}"

                    // Build the Docker image
                    sh """
                    docker build -t ${REGISTRY}/${REPOSITORY}:${IMAGE_TAG} .
                    docker tag ${REGISTRY}/${REPOSITORY}:${IMAGE_TAG} ${REGISTRY}/${REPOSITORY}:latest
                    """
                }
            }
        }
        stage('Push Image') {
            when {
                expression { return BUILD_STATUS != 'NOT_BUILT' }
            }
            steps {
                withCredentials([usernamePassword(credentialsId: 'harbor-credentials', passwordVariable: 'DOCKER_REGISTRY_PASSWORD', usernameVariable: 'DOCKER_REGISTRY_USERNAME')]) {
                    script {
                        // Log in to Docker registry
                        sh '''
                        echo $DOCKER_REGISTRY_PASSWORD | docker login ${REGISTRY} -u $DOCKER_REGISTRY_USERNAME --password-stdin
                        '''

                        // Push the Docker image to the registry
                        sh '''
                        docker push ${REGISTRY}/${REPOSITORY}:${IMAGE_TAG}
                        docker push ${REGISTRY}/${REPOSITORY}:latest
                        '''
                    }
                }
            }
        }
        stage('Sentry Release') {
            when {
                expression { return BUILD_STATUS != 'NOT_BUILT' }
            }
            steps {
                script {
                    withCredentials([string(credentialsId: 'sentry-auth-token', variable: 'SENTRY_AUTH_TOKEN')]) {
                        sh """
                        VERSION=\$(git rev-parse HEAD)
                        sentry-cli releases -o ${env.SENTRY_ORG} -p ${env.SENTRY_PROJECT} new \$VERSION || true
                        sentry-cli releases -o ${env.SENTRY_ORG} -p ${env.SENTRY_PROJECT} set-commits \$VERSION --auto || true
                        sentry-cli releases -o ${env.SENTRY_ORG} -p ${env.SENTRY_PROJECT} finalize \$VERSION || true
                        """
                    }
                }
            }
        }
    }
    post {
        success {
            script {
                if (!currentBuild.description) {
                    currentBuild.description = "Image: ${REGISTRY}/${REPOSITORY}:${IMAGE_TAG} built and pushed successfully"
                }
                
                // Send success notification email
                withCredentials([
                    string(credentialsId: 'mailjet-api-key', variable: 'MAIL_JET_API_KEY'),
                    string(credentialsId: 'mailjet-api-secret', variable: 'MAIL_JET_API_SECRET')
                ]) {
                    sh """curl -s \
                    -X POST \
                    --user \$MAIL_JET_API_KEY:\$MAIL_JET_API_SECRET \
                    https://api.mailjet.com/v3.1/send \
                    -H "Content-Type:application/json" \
                    -d '{
                        "Messages":[
                                {
                                        "From": {
                                                "Email": "${env.MAIL_JET_EMAIL_ADDRESS}",
                                                "Name": "Jenkins Notification"
                                        },
                                        "To": [
                                                {
                                                        "Email": "${env.MY_EMAIL_ADDRESS}",
                                                        "Name": "Development Team"
                                                }
                                        ],
                                        "Subject": "${currentBuild.description}",
                                        "TextPart": "Hola Development Team, your project ${currentBuild.fullDisplayName} : ${currentBuild.description}",
                                        "HTMLPart": "<h3>Hola Development Team, your project ${currentBuild.fullDisplayName} : ${currentBuild.description} </h3> <br> <p> Build Url: ${env.BUILD_URL}  </p>"
                                }
                        ]
                    }' || true"""
                }

                // Trigger deployment job dynamically
                build job: "${env.ENV_PROJECT_NAME}", parameters: [booleanParam(name: 'DEPLOY', value: true)], wait: false
            }
        }
        failure {
            script {
                // Send failure notification email
                withCredentials([
                    string(credentialsId: 'mailjet-api-key', variable: 'MAIL_JET_API_KEY'),
                    string(credentialsId: 'mailjet-api-secret', variable: 'MAIL_JET_API_SECRET')
                ]) {
                    sh """curl -s \
                    -X POST \
                    --user \$MAIL_JET_API_KEY:\$MAIL_JET_API_SECRET \
                    https://api.mailjet.com/v3.1/send \
                    -H "Content-Type:application/json" \
                    -d '{
                        "Messages":[
                                {
                                        "From": {
                                                "Email": "${env.MAIL_JET_EMAIL_ADDRESS}",
                                                "Name": "Jenkins Notification"
                                        },
                                        "To": [
                                                {
                                                        "Email": "${env.MY_EMAIL_ADDRESS}",
                                                        "Name": "Development Team"
                                                }
                                        ],
                                        "Subject": "${currentBuild.fullDisplayName} build failed",
                                        "TextPart": "Hola Development Team, your project ${currentBuild.fullDisplayName} build failed ${currentBuild.description} ",
                                        "HTMLPart": "<h3>Hola Development Team, your project ${currentBuild.fullDisplayName} build failed </h3> <br> <p> ${currentBuild.description}  </p>"
                                }
                        ]
                    }' || true"""
                }
            }
        }
        always {
            // Cleanup
            sh 'rm -f .env || true'
        }
    }
}
